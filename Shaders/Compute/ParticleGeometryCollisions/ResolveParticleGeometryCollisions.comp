// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp
//// REQUIRES ParticleBoundingBoxesBuffer.comp
// REQUIRES CollideableGeometryBuffer.comp

// Y and Z work group sizes default to 1
//layout (local_size_x = WORK_GROUP_SIZE_X) in;
layout (local_size_x = 512) in;

//// this is a thread-specific global so that it doesn't have to be copied into 
//// BoundingBoxesOverlap(...) umpteen times as this shader runs
//BoundingBox thisParticleBoundingBox;
//
//
///*------------------------------------------------------------------------------------------------
//Description:
//    Determines if two bounding boxes overlap.  Shocking description, I know.
//
//    Note: This is only a potential collision.  Bounding boxes are just boxes, but particles have 
//    a collision radius (circle), so it is possible to have an overlap of two boxes that doesn't 
//    result in the two particles' collision circles overlapping.
//Parameters: 
//    otherNodeBoundBox   A copy of the bounding box of the node to compare 
//                        thisThreadNodeBoundingBox against.
//Returns:    
//    True if they bounding boxes overlap, otherwise false.
//Creator:    John Cox, 6/2017
//------------------------------------------------------------------------------------------------*/
//bool BoundingBoxesOverlap(BoundingBox otherNodeBoundingBox)
//{
//    float overlapBoxLeft = max(thisThreadNodeBoundingBox._left, otherNodeBoundingBox._left);
//    float overlapBoxRight = min(thisThreadNodeBoundingBox._right, otherNodeBoundingBox._right);
//    float overlapBoxBottom = max(thisThreadNodeBoundingBox._bottom, otherNodeBoundingBox._bottom);
//    float overlapBoxTop = min(thisThreadNodeBoundingBox._top, otherNodeBoundingBox._top);
//
//    bool horizontalIntersection = (overlapBoxRight - overlapBoxLeft) > 0.0f;
//    bool verticalIntersection = (overlapBoxTop - overlapBoxBottom) > 0.0f;
//    return horizontalIntersection && verticalIntersection;
//}


/*------------------------------------------------------------------------------------------------
Description:
    I learned about the "perpendicular dot product" from here:
    http://www.dreamincode.net/forums/topic/329073-intersection-point-of-two-vectors/

    And here:
    http://devmag.org.za/2009/08/12/vector-fundamentals/

    Note: The "prependicular dot product" ONLY works in 2D.  It only considers X and Y and so 
    would be useless in 3D (unless you have a problem reduced to 2D, in which case it is 
    conceivably useful).
Parameters: None
Returns:    None
Creator:    John Cox, 6/2017
------------------------------------------------------------------------------------------------*/
float PerpDot(vec2 a, vec2 b)
{
    return ((a.x * b.y) - (a.y * b.x));
}

/*------------------------------------------------------------------------------------------------
Description:
    Each particle examines all the polygon faces in the CollideableGeometryBuffer and bounces 
    off them if necessary.

    Note: I learned of this intersection check via this forum post:
    http://www.dreamincode.net/forums/topic/329073-intersection-point-of-two-vectors/

    Consider two line segments "a" and "b".  Each are defined by a position vector + travel 
    vector.  Their intersection will occur at some fraction t (I could have chosen another 
    letter) from 0-1 between their start point + the travel vector.  That is:
    
    Intersection vector = a.start + t*a
    OR 
    Intersection vector = b.start + s*a ("s" is a different fraction between 0-1)

    Both will end up at the same point.

    For line segment "a", this fraction t is defined as 
    t = PerpendicularDot(c,b) / PerpendicularDot(a,b), where "c" is (b.start - a.start).  
    
    For line segment "b", this fraction s is defined as 
    s = PerpendicularDot(c,a) / PerpendicularDot(b,a), where "c" is (a.start - b.start).  
    
    These are line segments, so even if the line defined by their travel vectors eventually 
    intersect, the segments do not intersect if t < 0 or t > 1 (??else??).

    This ONLY works in 2D.  I don't have a visual understanding of why this works, but I worked 
    it out on paper and it does, so I'll use it.

    Also Note: I learned the reflection from here:
    http://www.3dkingdoms.com/weekly/weekly.php?a=2

    This works in 2D and 3D.
    
Parameters: None
Returns:    None
Creator:    John Cox, 6/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    uint threadIndex = gl_GlobalInvocationID.x;
    if (threadIndex >= uMaxNumParticles)
    {
        return;
    }
    else if (AllParticles[threadIndex]._isActive == 0)
    {
        return;
    }
    
    // in this function, "a" will be the particle travel vector and "b" will be the line along 
    // the polygon face
    Particle p = AllParticles[threadIndex];
    vec2 a = (p._currPos - p._prevPos).xy;
    for(uint polyCounter = 0; polyCounter < uMaxPolygons; polyCounter++)
    {
        PolygonFace polyFace = AllCollideableGeometry[polyCounter];
        vec2 b = (polyFace._end._pos - polyFace._start._pos).xy;
        vec2 c = (polyFace._start._pos - p._prevPos).xy;
        //vec2 c = (p._prevPos - polyFace._start._pos).xy;
        
        float s = PerpDot(a, c) / PerpDot(a, b);
        float t = PerpDot(b, c) / PerpDot(a, b);
        if (t < 0.0f || t > 1.0f || isinf(t) || isnan(t) ||
            s < 0.0f || s > 1.0f || isinf(s) || isnan(s))
        {
            // no intersection
            // Note: No intersection can happen a few ways:
            // - inf -> parallel
            // - t < 0 or t > 0 -> no intersection
            // - nan -> ??can this happen??
            continue;
        }

        AllParticles[threadIndex]._vel = vec4(0.0f, 0.0f, 0.0f, 0.0f);
        //AllParticles[threadIndex]._numNearbyParticles = 37;
        break;
        
        // both vertices normals are the same for any given PolygonFace, so either will work
        vec2 n = polyFace._start._normal.xy;
        
        // the particle crossed the line; bounce it
        // Note: Work out this equation on paper and it will hopefully make visual sense.  It 
        // did for me.
        // Also Note: The line segment remaining after the point of intersection is traveling in 
        // the same direction as the incident vector.  This algorithm to reflect a vector around 
        // a normal applies the magnitude of the incident vector to the reflection vector, so by 
        // using the line segment after the intersection as the incident line segment, the 
        // reflection vector will adopt its magnitude.  This will make the particle's resulting 
        // position only travel as far as necessary after the bounce.
        vec2 pointOfIntersection = p._prevPos.xy + (t * a);
        vec2 posIncidentVector = p._currPos.xy - pointOfIntersection;
        vec2 reflectedPosVector = posIncidentVector - ((2 * dot(posIncidentVector, n)) * n);
    
        // reflect the velocity in the same way
        // Note: The velocity vector is just a direction, so it doesn't need to be altered at 
        // the point of intersection like position does.  Just reflect it as is.
        vec2 reflectedVelVector = p._vel.xy - ((2 * dot(p._vel.xy, n)) * n);
    
        // update the particle positions will new values to reflect the bounce.
        //AllParticles[threadIndex]._prevPos = pointOfIntersection;
        //AllParticles[threadIndex]._currPos = pointOfIntersection + reflectedPosVector;
        //AllParticles[threadIndex]._vel = reflectedVelVector;
    
        AllParticles[threadIndex]._extraVec1 = p._prevPos;
        AllParticles[threadIndex]._extraVec2 = p._currPos;
        AllParticles[threadIndex]._extraVec3 = vec4(a.x, a.y, 0.0f, 0.0f);
        AllParticles[threadIndex]._extraVec4 = polyFace._start._pos;
        AllParticles[threadIndex]._extraVec5 = polyFace._end._pos;
        AllParticles[threadIndex]._extraVec6 = vec4(b.x, b.y, 0.0f, 0.0f);
        AllParticles[threadIndex]._extraVec7 = vec4(c.x, c.y, 0.0f, 0.0f);
        AllParticles[threadIndex]._extraVec8 = vec4(PerpDot(a, c), PerpDot(b, c), PerpDot(a,b), t);
        AllParticles[threadIndex]._isActive = int(polyCounter);
        
        AllParticles[threadIndex]._numNearbyParticles = 37;
    
        // it should only collide with 1 piece of geometry, so if the particle has already 
        // bounced off something, then this thread is done
        break;
    }
}

