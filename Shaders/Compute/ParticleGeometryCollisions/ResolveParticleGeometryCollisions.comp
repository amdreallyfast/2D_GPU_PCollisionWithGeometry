// REQUIRES Version.comp
// REQUIRES ComputeShaderWorkGroupSizes.comp
// REQUIRES SsboBufferBindings.comp
// REQUIRES CrossShaderUniformLocations.comp
// REQUIRES ParticleBuffer.comp
//// REQUIRES ParticleBoundingBoxesBuffer.comp
// REQUIRES CollideableGeometryBuffer.comp

// Y and Z work group sizes default to 1
//layout (local_size_x = WORK_GROUP_SIZE_X) in;
layout (local_size_x = 512) in;

//// this is a thread-specific global so that it doesn't have to be copied into 
//// BoundingBoxesOverlap(...) umpteen times as this shader runs
//BoundingBox thisParticleBoundingBox;
//
//
///*------------------------------------------------------------------------------------------------
//Description:
//    Determines if two bounding boxes overlap.  Shocking description, I know.
//
//    Note: This is only a potential collision.  Bounding boxes are just boxes, but particles have 
//    a collision radius (circle), so it is possible to have an overlap of two boxes that doesn't 
//    result in the two particles' collision circles overlapping.
//Parameters: 
//    otherNodeBoundBox   A copy of the bounding box of the node to compare 
//                        thisThreadNodeBoundingBox against.
//Returns:    
//    True if they bounding boxes overlap, otherwise false.
//Creator:    John Cox, 6/2017
//------------------------------------------------------------------------------------------------*/
//bool BoundingBoxesOverlap(BoundingBox otherNodeBoundingBox)
//{
//    float overlapBoxLeft = max(thisThreadNodeBoundingBox._left, otherNodeBoundingBox._left);
//    float overlapBoxRight = min(thisThreadNodeBoundingBox._right, otherNodeBoundingBox._right);
//    float overlapBoxBottom = max(thisThreadNodeBoundingBox._bottom, otherNodeBoundingBox._bottom);
//    float overlapBoxTop = min(thisThreadNodeBoundingBox._top, otherNodeBoundingBox._top);
//
//    bool horizontalIntersection = (overlapBoxRight - overlapBoxLeft) > 0.0f;
//    bool verticalIntersection = (overlapBoxTop - overlapBoxBottom) > 0.0f;
//    return horizontalIntersection && verticalIntersection;
//}


struct BoundingBox
{
    float _left;
    float _right;
    float _top;
    float _bottom;
};


/*------------------------------------------------------------------------------------------------
Description:
    I learned about the "perpendicular dot product" from here:
    http://www.dreamincode.net/forums/topic/329073-intersection-point-of-two-vectors/

    And here:
    http://devmag.org.za/2009/08/12/vector-fundamentals/

    Note: The "prependicular dot product" ONLY works in 2D.  It only considers X and Y and so 
    would be useless in 3D (unless you have a problem reduced to 2D, in which case it is 
    conceivably useful).
Parameters: None
Returns:    None
Creator:    John Cox, 6/2017
------------------------------------------------------------------------------------------------*/
float PerpDot(vec4 a, vec4 b)
{
    return ((a.x * b.y) - (a.y * b.x));
}

/*------------------------------------------------------------------------------------------------
Description:
    Each particle examines all the polygon faces in the CollideableGeometryBuffer and bounces 
    off them if necessary.

    Note: I learned of this intersection check via this forum post:
    http://www.dreamincode.net/forums/topic/329073-intersection-point-of-two-vectors/

    Consider two line segments "a" and "b".  Each are defined by a position vector + travel 
    vector.  Their intersection will occur at some fraction t (I could have chosen another 
    letter) from 0-1 between their start point + the travel vector.  That is:
    
    Intersection vector = a.start + t*a
    OR 
    Intersection vector = b.start + s*a ("s" is a different fraction between 0-1)

    Both will end up at the same point.

    For line segment "a", this fraction t is defined as 
    t = PerpendicularDot(c,b) / PerpendicularDot(a,b), where "c" is (b.start - a.start).  
    
    For line segment "b", this fraction s is defined as 
    s = PerpendicularDot(c,a) / PerpendicularDot(b,a), where "c" is (a.start - b.start).  
    
    These are line segments, so even if the line defined by their travel vectors eventually 
    intersect, the segments do not intersect if t < 0 or t > 1 (??else??).

    This ONLY works in 2D.  I don't have a visual understanding of why this works, but I worked 
    it out on paper and it does, so I'll use it.

    Also Note: I learned the reflection from here:
    http://www.3dkingdoms.com/weekly/weekly.php?a=2

    This works in 2D and 3D.
    
Parameters: None
Returns:    None
Creator:    John Cox, 6/2017
------------------------------------------------------------------------------------------------*/
void main()
{
    uint threadIndex = gl_GlobalInvocationID.x;
    if (threadIndex >= uMaxNumParticles)
    {
        return;
    }
    else if (AllParticles[threadIndex]._isActive == 0)
    {
        return;
    }
    
    Particle p = AllParticles[threadIndex];
    BoundingBox pBB;
    pBB._left = min(p._currPos.x, p._prevPos.x);
    pBB._right = max(p._currPos.x, p._prevPos.x);
    pBB._bottom = min(p._currPos.y, p._prevPos.y);
    pBB._top = max(p._currPos.y, p._prevPos.y);

    for(uint polyCounter = 0; polyCounter < uMaxPolygons; polyCounter++)
    {
        PolygonFace polyFace = AllCollideableGeometry[polyCounter];
        BoundingBox polyBB;
        polyBB._left = min(polyFace._end._pos.x, polyFace._start._pos.x);
        polyBB._right = max(polyFace._end._pos.x, polyFace._start._pos.x);
        polyBB._bottom = min(polyFace._end._pos.y, polyFace._start._pos.y);
        polyBB._top = max(polyFace._end._pos.y, polyFace._start._pos.y);


//        // first check if the particle is traveling near the polygon
//        BoundingBox overlapBox;
//        overlapBox._left = max(pBB._left, polyBB._left);
//        overlapBox._right = min(pBB._right, polyBB._right);
//        overlapBox._bottom = max(pBB._bottom, polyBB._bottom);
//        overlapBox._top = min(pBB._top, polyBB._top);
//        if (overlapBox._left > overlapBox._right ||
//            overlapBox._bottom > overlapBox._top)
//        {
//            // not near each other
//            continue;
//        }
        
//        // must be occupying the same space; check if the particle crossed the geometry
//        // Note: This is a crude check that only works for lines and that is not appropriate for line segments, but it is a decent first check.
//        vec4 lineToCurrParticle = p._currPos - polyFace._start._pos;
//        vec4 lineToPrevParticle = p._prevPos - polyFace._start._pos;
//        if (sign(dot(lineToCurrParticle, polyFace._start._normal)) ==
//            sign(dot(lineToPrevParticle, polyFace._start._normal)))
//        {
//            // prev and curr particle pos both hanging out on the same side of the geometry
//            continue;
//        }
        
        // crossed the line; figure out where
        // in this function, "a" will be the particle travel vector and "b" will be the line 
        // along the polygon face
        vec4 a = (p._currPos - p._prevPos);
        vec4 b = (polyFace._end._pos - polyFace._start._pos);
        vec4 c = (p._prevPos - polyFace._start._pos);   // source forum post is wrong; it isn't b.start - a.start, but rather the other way around
        float s = PerpDot(a, c) / PerpDot(a, b);
        float t = PerpDot(b, c) / PerpDot(a, b);

        bool sIsBad = s < 0.0f || s > 1.0f || isinf(s) || isnan(s);
        bool tIsBad = t < 0.0f || t > 1.0f || isinf(t) || isnan(t);
        if (sIsBad || tIsBad)
        {
            //??how? the particle's travel vector runs through this geometry's space and it crossed the line, so how could both the bad??

            // no intersection
            // Note: No intersection can happen a few ways:
            // - inf -> parallel
            // - t < 0 or t > 0 -> no intersection
            // - nan -> ??can this happen??
            continue;
        }

//            AllParticles[threadIndex]._numNearbyParticles = 37;
//
//            AllParticles[threadIndex]._extraVec1 = p._prevPos;
//            AllParticles[threadIndex]._extraVec2 = p._currPos;
//            AllParticles[threadIndex]._extraVec3 = vec4(a.x, a.y, 0.0f, 0.0f);
//            AllParticles[threadIndex]._extraVec4 = polyFace._start._pos;
//            AllParticles[threadIndex]._extraVec5 = polyFace._end._pos;
//            AllParticles[threadIndex]._extraVec6 = vec4(b.x, b.y, 0.0f, 0.0f);
//            AllParticles[threadIndex]._extraVec7 = vec4(c.x, c.y, 0.0f, 0.0f);
//            AllParticles[threadIndex]._extraVec8 = vec4(PerpDot(a, c), PerpDot(b, c), PerpDot(a,b), t);


        AllParticles[threadIndex]._vel = vec4(0.0f, 0.0f, 0.0f, 0.0f);
        //AllParticles[threadIndex]._numNearbyParticles = 37;
        break;
                
        // the particle crossed the line; bounce it
        // Note: Work out this equation on paper and it will hopefully make visual sense.  It 
        // did for me.
        // Also Note: The line segment remaining after the point of intersection is traveling in 
        // the same direction as the incident vector.  This algorithm to reflect a vector around 
        // a normal applies the magnitude of the incident vector to the reflection vector, so by 
        // using the line segment after the intersection as the incident line segment, the 
        // reflection vector will adopt its magnitude.  This will make the particle's resulting 
        // position only travel as far as necessary after the bounce.
        vec4 pointOfIntersection = p._prevPos + (t * a);
        vec4 posIncidentVector = p._currPos - pointOfIntersection;

        // both vertices normals are the same for any given PolygonFace, so either will work
        vec4 n = polyFace._start._normal;
        vec4 reflectedPosVector = posIncidentVector - ((2 * dot(posIncidentVector, n)) * n);
    
        // reflect the velocity in the same way
        // Note: The velocity vector is just a direction, so it doesn't need to be altered at 
        // the point of intersection like position does.  Just reflect it as is.
        vec4 reflectedVelVector = p._vel - ((2 * dot(p._vel, n)) * n);
    
        // update the particle positions will new values to reflect the bounce.
        AllParticles[threadIndex]._prevPos = pointOfIntersection;
        AllParticles[threadIndex]._currPos = pointOfIntersection + reflectedPosVector;
        AllParticles[threadIndex]._vel = reflectedVelVector;
//    
//        AllParticles[threadIndex]._extraVec1 = p._prevPos;
//        AllParticles[threadIndex]._extraVec2 = p._currPos;
//        AllParticles[threadIndex]._extraVec3 = vec4(a.x, a.y, 0.0f, 0.0f);
//        AllParticles[threadIndex]._extraVec4 = polyFace._start._pos;
//        AllParticles[threadIndex]._extraVec5 = polyFace._end._pos;
//        AllParticles[threadIndex]._extraVec6 = vec4(b.x, b.y, 0.0f, 0.0f);
//        AllParticles[threadIndex]._extraVec7 = vec4(c.x, c.y, 0.0f, 0.0f);
//        AllParticles[threadIndex]._extraVec8 = vec4(PerpDot(a, c), PerpDot(b, c), PerpDot(a,b), t);
//        AllParticles[threadIndex]._isActive = int(polyCounter);
//        
//        AllParticles[threadIndex]._numNearbyParticles = 37;
    
        // it should only collide with 1 piece of geometry, so if the particle has already 
        // bounced off something, then this thread is done
        break;
    }
}

